# -*- mode: org -*-
IDEAS/TODO:

* tasks

(setq debug-on-error t)

** TODO org-table to lisp
use

Eric, did you know that Carsten provided a function called 
org-table-to-lisp in org-6.06b?  I think with this you can 
refactor your code to be more modular and thus better 
maintainable and extensible.

** TODO look at the binary option for 3d plots
** TODO 3d plotting

** TODO add plot links
something like

[[plot:table]]

not sure what the part following the : should contain, possibly
options

maybe rather than a plot it should look more like the latex in org
format?? $ $

** TODO re-graph all graphs when publishing
important sub-problem is how to cycle through all graphs, especially
cycling through and re-graphing all graphs in a subtree, like the
latex image command. (maybe even displaying the graph over the plot
link.

** TODO sources of data to plot [1/4]
plotting functions should work with any list of data, not just
tables... would probably want to plot from...
- [X] tables
- [ ] elisp lists
- [ ] results of property searches
- [ ] comma/tab seperated strings
** TODO add reading of parameters from elsewhere in the org-file
Currently reading from adjacent =#+PLOT= lines, but would also like to
read from the current subtree, or even global to the file

*** comment lines
I can see good ways to specify parameters for a plot that would be quite
consistent with how Org deals with such things in similar situations.

1. A special comment line in the buffer, directly before the table, like

#+PLOT: table-to-gnuplot :xcol 1 :ycols (2 4 5 6) :title "Some string"

or

#+PLOT: table-to-R :script "/path/to/script"

The command can read these by macthing

(if (looking-at "#+PLOT: +\\([^ \t\r\n]+\\)\\( +.*\\)?")
     (let* ((func (intern (match-string 1)))
	   (params-plist
	    (if (match-end 2)
		(read (concat "(" (match-string 2 format) ")")))))

2. Use inherited properties to specify plotting parameters in a tree.


*** header properties
 > (defun org-table-gnuplot (params)
 > 
 > and params can be a property list of arbitrary size with properties like
 > 
 > :title "string"
 > :xcol N
 > :ycols (n1 n2 n3)
 > :labelrow N
 > 
 > etc etc.  This you could use to expose any amount of gnuplot options  
 > you would want.

this would just use the org-entry-get PLOT_TITLE etc...
** TODO bugs [1/4]
- [ ] after plotting 3d or grid data, sometime have to call the
      plotting command twice before the before a graph is generated
- [X] parentheses inside of quotes for title break the regexp,
      similarly "'s inside of ()'s will probably be a problem for
      specifying labels
- [ ] Got a "current buffer has no process" when tried from Windows
      Native GNU Emacs 22.2.1
- [ ] can wander too far and read options from nearby graphs
- [ ] sometimes graphs just don't work, many times saving the org-file
      and then re-graphing will fix this
- [ ] changing the buffer

*** changing the buffer
this already happens whenever tab is pressed in a table.


* mailing list discussion
** second
mainly just cut/pasted from mailing list discussion

 > 
 > 1) Would it ever make sense to graph/plot information which is not in
 >    an org-table, if so how would that information be stored?
 >   - function or equation in the gnuplot link
 >   - array of values in the link
 >   - latex function (cringe)
 >   - elsewhere
 > 2) It seems that it may be useful to automatically generate/update
 >    plots during publication of org-files to latex or html
 > 3) Currently I find it very useful to be able to see an initial plot
 >    of a table with a single command, however there should be a sliding
 >    scale from ease of plotting to greater control over the final plot.
 >    Maybe through specification of gnuplot options through properties,
 >    or simply specification of a gnuplot script.
First of all, I do believe it would be good to move the plotting
settings to outside the table, either before or after.

I can see good ways to specify parameters for a plot that would be quite
consistent with how Org deals with such things in similar situations.

1. A special comment line in the buffer, directly before the table, like

#+PLOT: table-to-gnuplot :xcol 1 :ycols (2 4 5 6) :title "Some string"

or

#+PLOT: table-to-R :script "/path/to/script"

The command can read these by matching

(if (looking-at "#+PLOT: +\\([^ \t\r\n]+\\)\\( +.*\\)?")
     (let* ((func (intern (match-string 1)))
	   (params-plist
	    (if (match-end 2)
		(read (concat "(" (match-string 2 format) ")")))))

2. Use inherited properties to specify plotting parameters in a tree.

 > 4) also clearly R is another plotting library of interest, how should
 >    different libraries be handled.
 > 5) would application of more powerful libraries like R to org-tables
 >    be useful as an alternative to calc, or is this beginning to look
 >    like a kitchen sink

** first

 > > 1) titling the graph lines, by their column headers (when present)
 > > 2) exposing some of the gnuplot options (with lines, with bars, title,
 > >   lt, etc...), the only problem there is how to expose them without
 > >   cluttering the interface
 > > 3) probably there are some more which would be useful...
 > 
 > 
 > The best way to make this extensible is to use a property list as a  
 > parameter to the function that creates the plot.
 > 
 > 
 > like this:
 > 
 > (defun org-table-gnuplot (params)
 > 
 > and params can be a property list of arbitrary size with properties like
 > 
 > :title "string"
 > :xcol N
 > :ycols (n1 n2 n3)
 > :labelrow N
 > 
 > etc etc.  This you could use to expose any amount of gnuplot options  
 > you would want.
 > 
 > Other ideas:
 > 
 > - I think it might be better if the link can be just before or after a  
 > table, so we could make the function search forward to the next table  
 > and use that.
 > 
 > - instead of using elisp links, we could define a new link type  
 > gnuplot: to do this.  Not required, but might make things more compact  
 > and clean.
